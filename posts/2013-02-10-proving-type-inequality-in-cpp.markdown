---
title: Proving Type Inequality in C++
---

It is trivial to prove type equality in Haskell (to the extent that
anything is every "proved" in Haskell). As for proving type
_inequality_, Conor McBride
[demonstrates](http://stackoverflow.com/a/14277376/125361) that this is
possible to do using type families. Today, I'd like to show some
techniques for doing the same in C++ with templates.

<!--more-->

First, let's come up with some notion of equality. We're going to base
our encoding off of the following pseudocode:

$$\begin{align}
\frac{\vdash\sigma : \star \qquad \vdash\tau : \star}{\vdash \sigma
\equiv \tau : \star}\tag{≡-type}
\end{align}$$

$$\begin{align}
\frac{\vdash\sigma : \star}{\vdash\ \hbox{refl} :
\sigma\equiv\sigma}\tag{≡-intro}
\end{align}$$

$$\begin{align}
\frac{\vdash x : \sigma \qquad \sigma\equiv\tau}{\vdash x : \tau}\tag{≡-conversion}
\end{align}$$

$$\begin{align}
\frac{\vdash \sigma\equiv\tau \qquad \vdash f : \star\to\star}{\vdash f(\sigma)\equiv f(\tau)}\tag{≡-congruence}
\end{align}$$

$$\begin{align}
\frac{\vdash \sigma\equiv\tau \qquad \vdash f : \star\to\star\qquad
\vdash x : f(\sigma)}{\vdash x : f(\tau)}
\tag{≡-transport}
\end{align}$$


### Encoding Equality

````{.Cpp}
#include <functional>
namespace Equality {
````

There is no term in `∀ A B. Eq<A,B>`; constructors are automatically
generated by C++, so we must explicitly delete it.

````{.Cpp}
    template <class A, class B>
    struct Eq { Eq() = delete; };
````

According to $\hbox{≡-intro}$ rule above, we can construct a term in
`∀ A. Eq<A,A>`:

````{.Cpp}
    template <class A>
    struct Eq<A,A> { Eq() {} };
````

Casting as in $\hbox{≡-conversion}$ is morally correct, but not
provable in C++, lacking any notion of dependent pattern matching and
refinement. Trusting in the soundness of our axioms, we do an unsafe
cast under the hood, given an equality proof.

````{.Cpp}
    template <class A, class B>
    B cast(Eq<A,B> refl, A x) {
        return *(B*)&x;
    }
````

Likewise, $\hbox{≡-congruence}$ is not provable in C++ for the same
reasons; we'll have to fudge the implementation, trusting the axioms.

````{.Cpp}
    template <template <class> class F, class A, class B>
    Eq<F<A>,F<B>> cong(Eq<A,B> refl) {
        auto fudge = Eq<F<A>,F<A>>();
        return *(Eq<F<A>,F<B>>*)&fudge;
    }
````

Finally, $\hbox{≡-transport}$ can be defined in terms of what we've
already done:

````{.Cpp}
    template <template <class> class F, class A, class B>
    F<B> transport(Eq<A,B> refl, F<A> x) {
        return cast(cong<F>(refl), d);
    }
}
````

### Encoding some Logic

In a quick digression that will prove necessary shortly, let's define
some basic types that will correspond to falsity, truth and negation:

````{.Cpp}
namespace Logic {
````

In the BHK interpretation of intuitionistic logic, falsity is simply a
proposition that has no proofs. So we can just provide a type without
any constructors:

````{.Cpp}
    struct Empty { Empty() = delete; };
````

To make a provable proposition, we can provide a type that does have a
constructor:

````{.Cpp}
    struct Unit { Unit () {} };
````

For one proposition $P$ to imply another proposition $Q$, we provide a
function which converts proofs of $P$ to proofs of $Q$:

````{.Cpp}
    template <class P, class Q>
    using Implication = std::function<Q(P)>;
````

Finally, we use *reductio ad absurdum* to refute a proposition:

````{.Cpp}
    template <class P>
    using Not = Implication<P,Empty>;
}
````

### Discrimination: Refuting Equalities

Finally, we are ready to encode the central conceit.

````{.Cpp}
namespace Refute {
    using namespace Logic;
    using namespace Equality;
````

First, we shall encode some type-level discrimination functions; so that
we can branch on types:

````{.Cpp}
    template <class A, class B, class T, class CaseA, class CaseB> struct If;

    template <class A, class B, class CaseA, class CaseB>
    struct If<A,B,A,CaseA,CaseB> {
        using apply = CaseA;
    };

    template <class A, class B, class CaseA, class CaseB>
    struct If<A,B,B,CaseA,CaseB> {
        using apply = CaseB;
    };
````

Because of some quirks in the way that C++ handles partial template
application, we must provide a bit of indirection for what comes next:

````{.Cpp}
    template <class A, class B>
    struct Discriminate {
        template <class T>
        using apply = typename If<A,B,T,Unit,Empty>::apply;
    };
````

If a path from `A` to `B` (in `Eq<A,B>`) actually exists, then we should be able to
transport any `F<A>` to `F<B>`; in this way, we can convert a proof of
`Eq<A,B>` to a proof of `Empty`.

````{.Cpp}
    template <class A, class B>
    typename Discriminate<A,B>::template apply<B> refute_equality(Eq<A,B> refl) {
        return transport<Discriminate<A,B>::template apply>(refl, Unit());
    }
}
````

### The Payoff

Now, given some different types, we can prove that they are not equal
using the kit that we have come up with so far:

````{.Cpp}
void demonstration() {
    using Equality::Eq;
    using Logic::Not;
    using Refute::refute_equality;

    struct Dog;
    struct Cat;

    Not<Eq<Cat,Dog>> cat_is_not_dog = refute_equality<Cat,Dog>;
}
````

The term `cat_is_not_dog` serves as a witness that `Cat` and `Dog` are
different types!
